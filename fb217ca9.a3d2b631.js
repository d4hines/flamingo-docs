(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{77:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return s})),t.d(n,"rightToc",(function(){return l})),t.d(n,"default",(function(){return u}));var a=t(2),i=t(6),r=(t(0),t(80)),o={title:"Verifying Your Program \u2714\ufe0f",sidebar_label:"Verifying Your Program\ufe0f"},s={unversionedId:"basics/verifying_your_program",id:"basics/verifying_your_program",isDocsHomePage:!1,title:"Verifying Your Program \u2714\ufe0f",description:"Running our First Analysis",source:"@site/docs\\basics\\verifying_your_program.md",permalink:"/docs/basics/verifying_your_program",editUrl:"https://github.com/flamingo-lang/flamingo-docs/edit/master/docs/basics/verifying_your_program.md",sidebar_label:"Verifying Your Program\ufe0f",sidebar:"sidebar",previous:{title:"Step 4: Axioms \ud83e\uddfe",permalink:"/docs/basics/axioms"},next:{title:"Intro \ud83d\udcc3",permalink:"/docs/todomvc/intro"}},l=[{value:"Running our First Analysis",id:"running-our-first-analysis",children:[]},{value:"Making Things More Interesting",id:"making-things-more-interesting",children:[]},{value:"Finding Rhyme and Reason",id:"finding-rhyme-and-reason",children:[]}],c={rightToc:l};function u(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"running-our-first-analysis"},"Running our First Analysis"),Object(r.b)("p",null,"Having written our fruit and basket system, it's now\nverify it for correctness. To do this, copy it into\na file (we'll call it ",Object(r.b)("inlineCode",{parentName:"p"},"fruit_and_basket.alm"),") and run\nthe following on the command line:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"flamingo verify fruit_and_basket.alm\n")),Object(r.b)("p",null,"You'll see output like the following:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"Thinking...\n\u2714\ufe0f No conflicts found!\n")),Object(r.b)("p",null,"But what does this mean? Well, recall that ALM defines ",Object(r.b)("em",{parentName:"p"},"state machines"),",\ngraphs where states are nodes and actions are edges between them. The goal\nof an ALM program is to define the state machine that includes every possible\n",Object(r.b)("em",{parentName:"p"},"valid")," state and transition of your program and no ",Object(r.b)("em",{parentName:"p"},"invalid")," state or transitions.\nSince ALM is a logic language, invalid states are modelled as ",Object(r.b)("em",{parentName:"p"},"logical\ncontradictions"),": a state is invalid if something inside that state is both\ntrue and false at the same time. Therefore, verifying an ALM program can be reduced\nto checking that there are no states with logical contradictions."),Object(r.b)("p",null,"Flamingo found no contradictions in our fruit and basket system. On the one hand,\nthis is great news! On the other hand, we must be careful: just because there are\nno ",Object(r.b)("em",{parentName:"p"},"contradictions")," doesn't mean something is ",Object(r.b)("em",{parentName:"p"},"correct"),". You must think carefully\nabout what it means for your system to be correct - that's something no machine can\ndecide for you. In the process, you'll come up with relationships between objects\nand constraints on those relationships. When you translate those into ALM state\nconstraints, Flamingo can assist you by automatically verifying those constraints\ndon't contradict each other. It's similar to\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://hypothesis.works/articles/what-is-property-based-testing/"}),"property-based testing"),"\n, only built into the heart of the language itself."),Object(r.b)("h2",{id:"making-things-more-interesting"},"Making Things More Interesting"),Object(r.b)("p",null,"Let's take a closer look at our fruit and basket system from the perspective of\nverification. Notice that our main relationships are described in the static and\nfluent functions, all of which are ",Object(r.b)("em",{parentName:"p"},"boolean")," functions, having a value of either\ntrue or false. Notice also that all of our axioms only define when the functions\n",Object(r.b)("em",{parentName:"p"},"become true"),", never when they become false. Thus, it's obvious Flamingo will find\nno contradictions: we only define one value, true, for each function."),Object(r.b)("p",null,"To illustrate this point, let's add a contrived rule to the end of our file\nfor ",Object(r.b)("inlineCode",{parentName:"p"},"can_bake_pie")," and see what happens."),Object(r.b)("p",null,"First in English:"),Object(r.b)("p",null,'"You can\'t bake a pie if there is an orange in your basket."'),Object(r.b)("p",null,"Then in ALM:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"// You can't bake a pie if there is an orange in your basket.\n-can_bake_pie if\n    instance(X, oranges),\n    in_basket(X).\n")),Object(r.b)("p",null,"When we try verifying our program again, Flamingo finds a problem:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"Thinking...\n\u274c\ufe0f Conflict found! Here's the trace to a counter-example:\n\nObjects\n====================================\n1 : put_fruit_in_basket where\n    selected_fruit = 4.\n2 : put_fruit_in_basket where\n    selected_fruit = 5.\n3 : put_fruit_in_basket where\n    selected-fruit = 6.\n4 : oranges.\n5 : apples where\n    variety = golden_delicious.\n6 : apples where\n    variety = golden_delicious.\n\nHistory\n=====================================\noccurs(1).\noccurs(2).\noccurs(3).\n\nConflict\n=====================================\ncan_bake_pie = true by axiom 5.\ncan_bake_pie = false by axiom 7.\n")),Object(r.b)("p",null,"(Your output may be slightly different as there's some non-determinism\ninvolved in finding counter-examples.)"),Object(r.b)("p",null,"What Flamingo is saying is that it found a set of objects and a sequence\nof actions that produced the conflict in the ",Object(r.b)("inlineCode",{parentName:"p"},"Conflict")," section of the output.\nSpecifically, it found that if you put an orange in the basket and then two\napples, ",Object(r.b)("inlineCode",{parentName:"p"},"can_bake_pie")," becomes both true and false by our fifth and seventh\naxioms respectively."),Object(r.b)("p",null,"This rule is silly, so let's replace it with a slightly less\nsilly rule. Suppose we ",Object(r.b)("em",{parentName:"p"},"really")," want to make sure we can bake\na pie. We could have an axiom like this:"),Object(r.b)("p",null,'"The basket must never be full if we can\'t bake a pie"'),Object(r.b)("p",null,"This could be expressed in ALM like so:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-alm"}),"-basket_is_full if -can_bake_pie.\n")),Object(r.b)("p",null,"Alternatively, we could phrase it in an logically equivalent way:"),Object(r.b)("p",null,'"It must never be the case that the basket is full and we cannot bake\na pie"'),Object(r.b)("p",null,'The phrase "it must never be the case" is equivalent to ',Object(r.b)("inlineCode",{parentName:"p"},"false")," in ALM\n(since ",Object(r.b)("inlineCode",{parentName:"p"},"false")," can never be ",Object(r.b)("inlineCode",{parentName:"p"},"true"),"), so we could write the same rule like\nso:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-alm"}),"false if basket_is_full, -can_bake_pie.\n")),Object(r.b)("p",null,"What form you write your rules in is up to you - in this case I like\nthe former, but often write the latter."),Object(r.b)("p",null,"As you can guess, Flamingo finds a problem with this constraint:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"$ flamingo verify fruit_and_basket.alm\nThinking...\n\u274c\ufe0f Conflict found! Here's the trace to a counter-example:\n\nObjects\n====================================\n1 : put_fruit_in_basket where\n    selected_fruit = 4.\n2 : put_fruit_in_basket where\n    selected_fruit = 5.\n3 : put_fruit_in_basket where\n    selected_fruit = 6.\n4 : oranges.\n5 : oranges.\n6 : oranges.\n\nHistory\n=====================================\noccurs(1).\noccurs(2).\noccurs(3).\n\nConflict\n=====================================\nbasket_is_full = true by axiom 3.\nbasket_is_full = false by axiom 7.\n")),Object(r.b)("p",null,"We filled up our basket with oranges, and so we didn't have enough apples\nfor a pie!"),Object(r.b)("p",null,'To prevent this "bug" in our program, we need an axiom that says something\nlike this:'),Object(r.b)("p",null,'"You can\'t put anything except an apple in the basket unless you have enough\napples to bake a pie."'),Object(r.b)("p",null,"For this, we need an executability condition (the type of axiom we skipped\nin the last section). Here's the syntax:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"impossible occurs(A) if\n    instance(A, put_fruit_in_basket),\n    selected_fruit(A) = Fruit\n    -instance(Fruit, apples),\n    -can_bake_pie.\n")),Object(r.b)("p",null,"Checking the program again finds no conflicts! "),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"$ flamingo verify fruit_and_basket.alm\nThinking...\n\u2714\ufe0f No conflicts found!\n")),Object(r.b)("h2",{id:"finding-rhyme-and-reason"},"Finding Rhyme and Reason"),Object(r.b)("p",null,"As we've said, in ALM, crafting correct programs comes down to defining good\nstates and transitions ruling out bad states and transitions. In the previous\nsection on axioms, we focused on defining the good states. At runtime, these\nare all your program needs to work. In this section, we've focused on ruling\nout bad states, which Flamingo uses at verification time to make sure your\nprogram is correct. In particular:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"We used ",Object(r.b)("em",{parentName:"li"},"negative state constraints")," to rule out bad states. These had the form\n",Object(r.b)("inlineCode",{parentName:"li"},"false if ...")," or ",Object(r.b)("inlineCode",{parentName:"li"},"-some_function if ..."),"."),Object(r.b)("li",{parentName:"ul"},"We used ",Object(r.b)("em",{parentName:"li"},"executability conditions")," to rule out bad transitions by saying which\nactions aren't allowed to occur in a particular state.")),Object(r.b)("p",null,"Understanding when to use which method is crucial for designing correct systems."),Object(r.b)("p",null,"Negative state constraints allow you to define what it means for your system\nto be correct ",Object(r.b)("em",{parentName:"p"},"at a every given instant in time"),". Because of their semantics,\nFlamingo can come behind you and check your logic, making sure your constraints\nare all internally consistent and finding counter-examples if any exist. If you\ndefine all possible error states as negative constraints and Flamingo verifies\nyour program as consistent, you can be sure that your program will never enter\na bad state at runtime (up to certain conditions we'll discuss in the more extended\nTodoMVC tutorial)."),Object(r.b)("p",null,"By contrast, when you use an executability condition, you're telling Flamingo\n\"Trust me, it's ",Object(r.b)("em",{parentName:"p"},"impossible"),' for this particular action to occur if this\nparticular condition is true", and Flamingo will indeed trust you. If that\naction ',Object(r.b)("em",{parentName:"p"},"does")," occur in that state, it will produce a runtime error, potentially\ncrashing your program! Be absolutely sure that the given situation ",Object(r.b)("em",{parentName:"p"},"really is\nimpossible"),' before using an executability condition. In our fruit and basket\nexample, if we were designing a GUI driven by our ALM program, we might achieve\nthis by disabling the "Put Fruit in Basket" button unless our criteria were met.'),Object(r.b)("p",null,"The last item of note for verification is that, at present, Flamingo can only\nverify ",Object(r.b)("em",{parentName:"p"},"finite")," domains, that is, where every sort has some fixed number of objects\nin it (extending Flamingo to infinite domains is the subject\nof my Master's thesis!). Usually, only a small number of objects in each sort\nis required to find subtle bugs in your axioms."),Object(r.b)("p",null,"Phew! We've designed and verified our first system with Flamingo \ud83c\udf7b!\nAlong the way, we've learned the handful of constructs that make up the\nALM language, all of which can be scaled to produce elegant encodings of\nlarge, complex, formally verified systems!"),Object(r.b)("p",null,"In the next tutorial, we'll learn some of the tricks of the trade for modeling\nlarger, more realistic systems, as well as how to hook Flamingo's runtime up\nto the DOM to produce working UI!"))}u.isMDXComponent=!0},80:function(e,n,t){"use strict";t.d(n,"a",(function(){return b})),t.d(n,"b",(function(){return d}));var a=t(0),i=t.n(a);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=i.a.createContext({}),u=function(e){var n=i.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},b=function(e){var n=u(e.components);return i.a.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return i.a.createElement(i.a.Fragment,{},n)}},m=i.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),b=u(t),m=a,d=b["".concat(o,".").concat(m)]||b[m]||p[m]||r;return t?i.a.createElement(d,s(s({ref:n},c),{},{components:t})):i.a.createElement(d,s({ref:n},c))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,o=new Array(r);o[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<r;c++)o[c]=t[c];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);